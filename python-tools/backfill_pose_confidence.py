#!/usr/bin/env python3
"""
Backfill joint confidence metadata into existing pose JSON files.

Reads pose files generated by earlier pipelines, recalculates joint
angles from the stored keypoints, and attaches an `angleConfidence`
map so the mobile app can reason about pose quality without relying
on zeroed angles.
"""

from __future__ import annotations

import argparse
import json
import math
from pathlib import Path
from typing import Dict, Iterable, Tuple

JOINT_MAP: Dict[str, Tuple[str, str, str]] = {
    "leftArm": ("leftShoulder", "leftElbow", "leftWrist"),
    "rightArm": ("rightShoulder", "rightElbow", "rightWrist"),
    "leftThigh": ("leftHip", "leftKnee", "leftAnkle"),
    "rightThigh": ("rightHip", "rightKnee", "rightAnkle"),
}

DUPLICATED_JOINTS = {
    "leftElbow": "leftArm",
    "rightElbow": "rightArm",
    "leftLeg": "leftThigh",
    "rightLeg": "rightThigh",
}

# Zero vector threshold - matches TypeScript ZERO_VECTOR_THRESHOLD (1e-9)
EPSILON = 1e-9


def calculate_angle(p1: Dict, p2: Dict, p3: Dict) -> float:
    """Return the geometric angle between three points."""
    v1 = (p1["x"] - p2["x"], p1["y"] - p2["y"])
    v2 = (p3["x"] - p2["x"], p3["y"] - p2["y"])

    mag1 = math.hypot(*v1)
    mag2 = math.hypot(*v2)

    if mag1 <= EPSILON or mag2 <= EPSILON:
        return 0.0

    cos_angle = (v1[0] * v2[0] + v1[1] * v2[1]) / (mag1 * mag2)
    cos_angle = max(-1.0, min(1.0, cos_angle))
    return math.degrees(math.acos(cos_angle))


def joint_confidence(points: Iterable[Dict]) -> float:
    """Return the minimum confidence value across the provided points."""
    confidences = [float(point.get("confidence", 0.0)) for point in points]
    if not confidences:
        return 0.0
    return min(confidences)


def recalculate_angles(keypoints: Dict[str, Dict]) -> Tuple[Dict[str, float], Dict[str, float]]:
    """Recompute joint angles plus their confidence metadata."""
    angles: Dict[str, float] = {
        "leftArm": 0.0,
        "rightArm": 0.0,
        "leftElbow": 0.0,
        "rightElbow": 0.0,
        "leftThigh": 0.0,
        "rightThigh": 0.0,
        "leftLeg": 0.0,
        "rightLeg": 0.0,
    }
    angle_confidence: Dict[str, float] = {key: 0.0 for key in angles}

    for joint, triple in JOINT_MAP.items():
        points = [keypoints.get(name) for name in triple]
        if any(point is None for point in points):
            continue

        confidence = joint_confidence(points)  # type: ignore[arg-type]
        angle_confidence[joint] = confidence
        if confidence == 0.0:
            continue

        angles[joint] = calculate_angle(points[0], points[1], points[2])  # type: ignore[arg-type]

    for duplicate, source in DUPLICATED_JOINTS.items():
        angle_confidence[duplicate] = angle_confidence.get(source, 0.0)
        angles[duplicate] = angles.get(source, 0.0)

    return angles, angle_confidence


def process_pose_file(path: Path, dry_run: bool = False) -> None:
    """Update a single pose JSON file in-place."""
    with path.open("r") as handle:
        data = json.load(handle)

    frames = data.get("frames", [])
    for frame in frames:
        keypoints = frame.get("keypoints", {})
        angles, angle_confidence = recalculate_angles(keypoints)
        frame["angles"] = angles
        frame["angleConfidence"] = angle_confidence

    if dry_run:
        print(f"[dry-run] Would update {path} ({len(frames)} frames)")
        return

    with path.open("w") as handle:
        json.dump(data, handle, indent=2)
        handle.write("\n")
    print(f"âœ“ Updated {path.name} with angle confidence metadata")


def main() -> None:
    parser = argparse.ArgumentParser(description="Inject joint confidence metadata into pose JSON files.")
    parser.add_argument(
        "--poses-dir",
        type=Path,
        default=Path("../mobile/assets/poses"),
        help="Directory containing pose JSON files (default: ../mobile/assets/poses)",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="List files that would be updated without modifying them.",
    )

    args = parser.parse_args()

    pose_files = sorted(args.poses_dir.glob("*.json"))
    if not pose_files:
        print(f"No pose files found in {args.poses_dir}")
        return

    for pose_file in pose_files:
        process_pose_file(pose_file, dry_run=args.dry_run)


if __name__ == "__main__":
    main()
